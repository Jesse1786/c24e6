# Overloading Operators in Python

## Introduction
Overloading operators refers to giving an operator (such as +, -, or >) functionality beyond its default operational logic. For example, in Python the + operator is overloaded by the string class to concatenate the two strings. However, an error is raised if the operation hasn't been defined for two input types.

```
>>> "hello " + "world!"  
"hello world!"  

>>> "abc" + 5  
error!
```

## Purpose
Overloading operators is primarily done by the user when they want to define operators for user defined classes, and provides advantages such as making the code more readable and logical. 

For example, consider an user defined class called Vector, which represents a vector in Euclidean space. It would make sense for this class to have logic for operators such as addition and subtraction. When these operators are implemented in the Vector class, it is referred to as overloading operators. This is similar to how function overloading refers to how a function's behaviour is different depending on the type and number of parameters. 

## How to Overload Operators in Python
### Incomplete Vector Class Implementation
```
class Vector:
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
```

Consider the above incomplete implementation of our Vector class that represents some vector. If we were to instantiate two vectors and try to apply the operator + on them, we would get an error.

```
>>> v1 = Vector(2, 5)
>>> v2 = Vector(7, 7)
>>> v1 + v2
error!
```

The reason for the error is because the + operator hasn't been overloaded for our Vector class, so Python doesn't know how to apply the operator to our Vector object. So how can we overload the operator so that we can add Vectors through the + operator? Overloading operators in python is actually quite simple. Based on the Python documentation, we just need to define the corresponding methods in our class. For the operators + and -, the methods are `__add__` and `__sub__`. These functions with underscores are called _special functions_ in Python.

For more information, refer to https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types

### Vector Class Implementation
```
class Vector:
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2

    def __add__(self, other):
        return (self.p1 + other.p1, self.p2 + other.p2)

    def __sub__(self, other):
        return (self.p1 - other.p1, self.p2 - other.p2)
        
    def __mul__(self, num):
        return (self.p1 * num, self.p2 * num)
```

The above implementation of the Vector class overloads the +, -, and * operators. Now, when we run `v1 + v2` python calls `v1.__add__(v2)`. The case for the other operators is similar.

```
>>> v1 = Vector(5, 6)
>>> v2 = Vector(2, 2)
>>> v1 + v2
(7, 8)
>>> v1 - v2
(3, 4)
>>> v1 * 2
(10, 12)
```

We also need to note that when we overload these operators, the standard rules of math such as commutivity may not necessarily apply.

### Grocery List Implementation
```
class GroceryList:
    def __init__(self, items):
        self.items = items

    def __add__(self, other):
        for i in other.items:
            if i not in self.items:
                self.items.append(i)
        return self.items

    def __sub__(self, other):
        for i in other.items:
            if i in self.items:
                self.items.remove(i)
        return self.items
    
    def get(self):
        return self.items
```

Above we have an implementation of a grocery list. We can add two grocery lists together to merge the items, or subtract one grocery list from another to remove items already bought. However, commutivity does not apply with our overloaded operator.

```
>>> g1 = GroceryList(["apples", "oranges", "milk"])
>>> g2 = GroceryList(["tomatoes", "oranges", "bread"])
>>> g1 + g2
['apples', 'oranges', 'milk', 'tomatoes', 'bread']
>>> g2 + g1
['tomatoes', 'oranges', 'bread', 'apples', 'milk']
```

## Conclusion
The ability to overload operators in Python is useful and provides some advantages in code readability and logic. It also allows users to manually define operators for their user defined classes. However, caution should be exercised when overloading operators, as subsequent users of the class may be caught by surprise at unexpected behaviour. 

Another issue of note with operator overloading when paralleled with numeric operators is that standard rules of math such as communtivity may not apply for the overloaded operators of user defined classes. For example, a + b might not necessarily equal b + a.
